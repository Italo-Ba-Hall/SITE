<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>/-HALL-DEV - Decodificando o Amanhã</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #080808;
            color: #ffffff;
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
        }
        #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
            transition: opacity 1s ease-out;
        }
        .animation-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            /* ATUALIZADO: Adicionada transição de transform para o recuo */
            transition: opacity 1.5s ease-out, transform 1.5s cubic-bezier(0.7, 0, 0.3, 1);
        }
        .animation-container.hidden {
            opacity: 0;
            /* ATUALIZADO: Efeito de recuo (scale down) */
            transform: scale(0.5);
            pointer-events: none;
        }
        #fibonacci-svg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1.15);
            width: 90vw;
            height: 90vh;
        }
        #fibonacci-svg path, #fibonacci-svg text {
            transition: opacity 1s ease-out;
        }
        .content {
            position: absolute;
            top: 50%;
            left: 50%;
            /* ATUALIZADO: Começa menor para o efeito de "zoom in" */
            transform: translate(-50%, -50%) scale(0.8);
            z-index: 10;
            text-align: center;
            opacity: 0;
            /* ATUALIZADO: Transição mais suave para opacity e transform */
            transition: opacity 2s cubic-bezier(0.25, 1, 0.5, 1), transform 2s cubic-bezier(0.25, 1, 0.5, 1);
            pointer-events: none;
            width: 90%;
            max-width: 700px;
        }
        .content.visible {
            opacity: 1;
            /* ATUALIZADO: Cresce para o tamanho normal */
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }
        .logo {
            font-size: 3.5rem;
            md:font-size: 4rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        .subtitle {
            font-size: 0.875rem;
            md:font-size: 1rem;
            font-weight: 300;
            letter-spacing: 0.2em;
            color: #00e5ff;
            text-transform: uppercase;
            margin-bottom: 2.5rem;
        }
        .prompt-container {
            background-color: rgba(1, 1, 1, 0.8);
            border: 1px solid #1a1a1a;
            padding: 1.5rem;
            text-align: left;
            border-radius: 4px;
            font-size: 1rem;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.5);
            cursor: text;
            backdrop-filter: blur(3px);
        }
        .prompt-line { display: flex; align-items: center; }
        .prompt-prefix { color: #cccccc; margin-right: 0.5rem; }
        .prompt-text { color: #ffffff; }
        .prompt-cursor {
            display: inline-block;
            background-color: #ffffff;
            width: 9px;
            height: 1.1rem;
            margin-left: 2px;
            animation: blink 1s steps(2, start) infinite;
        }
        .actual-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            z-index: -1;
            cursor: text;
        }
        @keyframes blink { to { visibility: hidden; } }
        
        /* Modal de Resultado */
        .result-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); backdrop-filter: blur(5px); z-index: 100; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        .result-modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .result-modal-content { background-color: #010101; border: 1px solid #00e5ff; border-radius: 8px; padding: 2rem; width: 90%; max-width: 800px; max-height: 85vh; overflow-y: auto; transform: scale(0.9); transition: transform 0.5s; font-family: 'Roboto Mono', monospace; }
        .result-modal-overlay.visible .result-modal-content { transform: scale(1); }
        .result-title { color: #00e5ff; font-size: 1.5rem; margin-bottom: 1.5rem; border-bottom: 1px solid rgba(0, 229, 255, 0.3); padding-bottom: 1rem; }
        .result-text { line-height: 1.8; text-align: left; white-space: pre-wrap; color: #cccccc; }
        .result-text h3 { color: #00e5ff; font-size: 1.1rem; margin-top: 1.5rem; margin-bottom: 0.5rem; }
        .result-text ul { list-style-type: none; padding-left: 1rem; }
        .result-text li::before { content: '» '; color: #00e5ff; margin-right: 0.5rem; }
        .result-text li { margin-bottom: 0.5rem; }
        .result-text strong { color: #ffffff; font-weight: 700; }
        .close-button { position: absolute; top: 1rem; right: 1rem; background: none; border: none; color: #fff; font-size: 2rem; cursor: pointer; line-height: 1; }
    </style>
</head>
<body class="bg-black">

    <canvas id="backgroundCanvas"></canvas>
    <div class="animation-container" id="animationContainer">
        <!-- O SVG vetorizado é inserido aqui -->
        <svg id="fibonacci-svg" viewBox="250 200 450 350" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <style>
                path {
                    stroke: #ffffff;
                    stroke-width: 2;
                    fill: none;
                }
                text {
                    font-family: 'Roboto Mono', monospace;
                    font-size: 20px;
                    fill: #ffffff;
                    stroke: none;
                }
                #slogan text {
                    font-size: 11px; 
                    fill: #444444;
                    text-anchor: middle;
                }
            </style>
            <g id="linhas-construcao" stroke-dasharray="4, 4">
                <path d="M 300,250 L 650,250"/> <path d="M 650,250 L 650,500"/>
                <path d="M 300,500 L 650,500"/> <path d="M 300,250 L 300,500"/>
                <path d="M 400,400 L 430,405"/> <path d="M 430,405 L 390,445"/>
                <path d="M 390,445 L 400,400"/> <path d="M 390,445 L 325,380"/>
                <path d="M 325,380 L 430,275"/> <path d="M 430,275 L 390,445"/>
            </g>
            <g id="quadrados-solidos">
                <path d="M 400,400 L 405,400 L 405,405 L 400,405 Z"/>
                <path d="M 400,400 L 390,400 L 390,390 L 400,390 Z"/>
                <path d="M 405,405 L 430,405 L 430,380 L 405,380 Z"/>
                <path d="M 390,445 L 430,445 L 430,405 L 390,405 Z"/>
                <path d="M 390,445 L 325,445 L 325,380 L 390,380 Z"/>
            </g>
            <g id="numeros">
                <text x="410" y="395">5</text> <text x="370" y="420">13</text>
                <text x="350" y="360">21</text> <text x="450" y="330">34</text>
            </g>
            <g id="espiral">
                <path d="M 400,400 m -5,0 a 5,5 0 1,1 10,0 a 5,5 0 1,1 -10,0"/>
                <path d="M 405,400 A 5,5 0 0,1 400,405"/>
                <path d="M 400,405 A 10,10 0 0,1 390,395"/>
                <path d="M 390,395 A 15,15 0 0,1 405,380"/>
                <path d="M 405,380 A 25,25 0 0,1 430,405"/>
                <path d="M 430,405 A 40,40 0 0,1 390,445"/>
                <path d="M 390,445 A 65,65 0 0,1 325,380"/>
                <path d="M 325,380 A 105,105 0 0,1 430,275"/>
                <path d="M 430,275 A 170,170 0 0,1 600,445"/>
            </g>
            <g id="slogan">
                <text id="slogan-text" x="475" y="490">CODE, the new religion</text>
                <rect id="slogan-cursor" x="585" y="482" width="5" height="10" fill="#444444" opacity="0"/>
            </g>
        </svg>
    </div>

    <div id="mainContent" class="content">
        <div class="logo">/-HALL-DEV</div>
        <div class="subtitle">Development &amp; Innovation</div>
        <div id="interfaceContainer">
             <div class="prompt-container" onclick="document.getElementById('unifiedInput').focus()">
                 <div class="prompt-line">
                    <span class="prompt-prefix">/-HALL-DEV&gt;</span>
                    <span id="promptText" class="prompt-text"></span>
                    <span class="prompt-cursor"></span>
                </div>
                <input type="text" id="unifiedInput" class="actual-input" autofocus>
            </div>
        </div>
    </div>

    <div id="resultModal" class="result-modal-overlay"> <!-- Modal para API Gemini --> </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const bgCanvas = document.getElementById('backgroundCanvas');
            const bgCtx = bgCanvas.getContext('2d');
            const svg = document.getElementById('fibonacci-svg');
            const animationContainer = document.getElementById('animationContainer');
            const mainContent = document.getElementById('mainContent');

            let width = bgCanvas.width = window.innerWidth;
            let height = bgCanvas.height = window.innerHeight;
            
            let rainParticles = [];
            let circuitParticles = [];
            let animationMode = 'rain';

            function setupRain() {
                rainParticles = [];
                const columnCount = Math.floor(width / 20);
                for (let i = 0; i < columnCount; i++) {
                    rainParticles.push({ x: i * 20, y: Math.random() * height, speed: 0.5 + Math.random() * 2 });
                }
            }

            function setupCircuits() {
                circuitParticles = [];
                const particleCount = Math.floor((width * height) / 20000);
                for (let i = 0; i < particleCount; i++) {
                    circuitParticles.push({
                        x: Math.random() * width, y: Math.random() * height,
                        vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5,
                        radius: 1.5 + Math.random() * 1
                    });
                }
            }

            function animateBackground() {
                if (animationMode === 'rain') {
                    drawNumberRain();
                } else {
                    drawPulsatingCircuits();
                }
                requestAnimationFrame(animateBackground);
            }

            function drawNumberRain() {
                bgCtx.fillStyle = 'rgba(8, 8, 8, 0.1)';
                bgCtx.fillRect(0, 0, width, height);
                bgCtx.font = '16px Roboto Mono';
                bgCtx.fillStyle = `rgba(0, 229, 255, 0.2)`;
                for (const p of rainParticles) {
                    const char = Math.random() > 0.5 ? '0' : '1';
                    bgCtx.fillText(char, p.x, p.y);
                    p.y += p.speed;
                    if (p.y > height) p.y = 0;
                }
            }

            function drawPulsatingCircuits() {
                bgCtx.fillStyle = 'rgba(8, 8, 8, 0.1)';
                bgCtx.fillRect(0, 0, width, height);

                for (let i = 0; i < circuitParticles.length; i++) {
                    const p1 = circuitParticles[i];
                    p1.x += p1.vx; p1.y += p1.vy;
                    if (p1.x < 0 || p1.x > width) p1.vx *= -1;
                    if (p1.y < 0 || p1.y > height) p1.vy *= -1;

                    bgCtx.beginPath();
                    bgCtx.arc(p1.x, p1.y, p1.radius, 0, Math.PI * 2);
                    bgCtx.fillStyle = 'rgba(0, 229, 255, 0.8)';
                    bgCtx.fill();

                    for (let j = i + 1; j < circuitParticles.length; j++) {
                        const p2 = circuitParticles[j];
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 150) {
                            bgCtx.beginPath();
                            bgCtx.moveTo(p1.x, p1.y);
                            bgCtx.lineTo(p2.x, p2.y);
                            bgCtx.strokeStyle = `rgba(0, 229, 255, ${1 - dist / 150})`;
                            bgCtx.lineWidth = 0.5;
                            bgCtx.stroke();
                        }
                    }
                }
            }
            
            window.addEventListener('resize', () => {
                width = bgCanvas.width = window.innerWidth;
                height = bgCanvas.height = window.innerHeight;
                setupRain();
                setupCircuits();
            });

            const elementsToAnimate = [...svg.querySelectorAll('path, text')].filter(Boolean);
            elementsToAnimate.forEach(el => {
                if (el.tagName === 'path') {
                    const length = el.getTotalLength();
                    el.style.strokeDasharray = length;
                    el.style.strokeDashoffset = length;
                }
                el.style.opacity = '0';
            });

            const animateElement = (el, delay, duration) => {
                return new Promise(resolve => {
                    setTimeout(() => {
                        el.style.transition = `stroke-dashoffset ${duration / 1000}s ease-in-out, opacity ${duration / 1000}s ease-in-out`;
                        if (el.tagName === 'path') el.style.strokeDashoffset = '0';
                        el.style.opacity = '1';
                        setTimeout(resolve, duration); 
                    }, delay);
                });
            };

            const typeWriter = (el, delay) => {
                 return new Promise(resolve => {
                    setTimeout(() => {
                        const text = el.textContent;
                        el.textContent = '';
                        el.style.opacity = '1';
                        let i = 0;
                        const interval = setInterval(() => {
                            if (i < text.length) {
                                el.textContent += text.charAt(i);
                                i++;
                            } else {
                                clearInterval(interval);
                                resolve();
                            }
                        }, 80);
                    }, delay);
                });
            };

            const runIntroAnimation = async () => {
                let delay = 0;
                const fastDuration = 500;
                const spiralDuration = 1500;

                const groups = ['#linhas-construcao path', '#quadrados-solidos path', '#numeros text'];
                const delays = [20, 40, 60];

                for (let i = 0; i < groups.length; i++) {
                    const elements = svg.querySelectorAll(groups[i]);
                    delay = 0;
                    for (const el of elements) { animateElement(el, delay, fastDuration); delay += delays[i]; }
                    await new Promise(r => setTimeout(r, delay + fastDuration));
                }

                delay = 0;
                const spiralPaths = svg.querySelectorAll('#espiral path');
                for (const path of spiralPaths) { animateElement(path, delay, spiralDuration); delay += 100; }
                await new Promise(r => setTimeout(r, delay + spiralDuration));

                await typeWriter(svg.querySelector('#slogan-text'), 0);
                
                const cursor = svg.querySelector('#slogan-cursor');
                cursor.style.opacity = '1';
                await new Promise(r => setTimeout(r, 400));
                cursor.style.opacity = '0';
                await new Promise(r => setTimeout(r, 400));
                cursor.style.opacity = '1';
                await new Promise(r => setTimeout(r, 400));
                cursor.style.opacity = '0';
                await new Promise(r => setTimeout(r, 200));

                animationContainer.classList.add('hidden');
                mainContent.classList.add('visible');
                animationMode = 'circuit';
                document.getElementById('unifiedInput').focus();
            };

            setupRain();
            setupCircuits();
            animateBackground();
            runIntroAnimation();
        });

        // --- Lógica da API Gemini e UI (sem alterações) ---
        const unifiedInput = document.getElementById('unifiedInput');
        const promptText = document.getElementById('promptText');
        const resultModal = document.querySelector('.result-modal-overlay');

        unifiedInput.addEventListener('input', () => { promptText.textContent = unifiedInput.value; });
        unifiedInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') handleUnifiedInput(); });

        async function handleUnifiedInput() {
            const userInput = unifiedInput.value.trim();
            if (!userInput) return;
            unifiedInput.value = '';
            promptText.textContent = ''; 
            console.log(`Chamando API para: ${userInput}`);
        }
    </script>
</body>
</html>
